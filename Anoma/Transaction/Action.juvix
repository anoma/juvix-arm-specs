module Anoma.Transaction.Action;

import Stdlib.Prelude open;
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};
import Data.Set as Set open using {Set; union; intersection};
import Anoma.Resource as Resource open;
import Anoma.Proving.Types open using {ProofRecord};
import Anoma.Proving.ProofRecordSet as ProofRecordSet open using {ProofRecordSet};
import Anoma.Math open using {disjointUnion};
import Anoma.Transaction.AppData open using {AppData};

--- The record describing an action and defining the proof context.
--- Proofs includes resource logic and compliance proofs of created and consumed resources.
--- The latter include multiple constraints such as the
--- - non-existence of created ;Resource;s in the commitment tree
--- - existence of consumed ;Resource;s in the commitment tree
--- - non-existence of consumed ;Resource;s in the nullifier set.
type Action :=
  mkAction {
    commitments : Set Resource.Commitment;
    nullifiers : Set Resource.Nullifier;
    proofs : ProofRecordSet;
    appData : AppData
  };

type DisjointSetError :=
  | NonDisjointCommitmentsError (Set Resource.Commitment)
  | NonDisjointNullifiersError (Set Resource.Nullifier);

--- Composes two ;Action; objects.
composeActions (a1 a2 : Action) : Result DisjointSetError Action :=
  case
    disjointUnion (Action.commitments a1) (Action.commitments a2)
      , disjointUnion (Action.nullifiers a1) (Action.nullifiers a2)
  of
    | error duplicatedCommitments, _ := error (NonDisjointCommitmentsError duplicatedCommitments)
    | _, error duplicatedNullifiers := error (NonDisjointNullifiersError duplicatedNullifiers)
    | ok commitments, ok nullifiers :=
      ok
        mkAction@{
          commitments;
          nullifiers;
          appData := union (Action.appData a1) (Action.appData a2);
          proofs := ProofRecordSet.empty
        };

--- Verifies an ;Action; by verifying all proofs in the ;ProofRecordSet;.
verifyAction (a : Action) : Bool := ProofRecordSet.verify (Action.proofs a);

module ActionInternal;
  --- Compares two ;Action; objects.
  compare (lhs rhs : Action) : Ordering :=
    let
      prod (a : Action) : _ :=
        Action.commitments a, Action.nullifiers a, Action.proofs a, Action.appData a;
    in Ord.cmp (prod lhs) (prod rhs);

  --- Implements the ;Ord; trait for ;Action;.
  instance
  Action-Ord : Ord Action := mkOrd compare;

  --- Implements the ;Eq; trait for ;Action;.
  instance
  Action-Eq : Eq Action := fromOrdToEq;
end;
