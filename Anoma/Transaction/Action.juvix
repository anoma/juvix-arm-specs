module Anoma.Transaction.Action;

import Stdlib.Prelude open using {Bool; Pair; Eq; ==; Ord; Ordering; mkOrd; Maybe; ,; fromMaybe; maybe; just; nothing; Result; error; ok};
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};
import Data.Set as Set open using {Set; union; intersection};
import Anoma.Resource.Index as Resource open using {Resource};
import Anoma.ProvingSystem.Types open using {ProofRecord; ProofRecordSet; module ProofRecordSet};

module AppDataInternal;
  --- A fixed-size data type encoding the lookup key of application data being part of an action.
  axiom AppDataKey : Type;

  --- A fixed-size data type encoding the lookup value of application data being part of an action.
  axiom AppDataValue : Type;

  --- Compares two ;AppDataKey;s.
  axiom compareAppDataKey : AppDataKey -> AppDataKey -> Ordering;

  --- Compares two ;AppDataValue;s.
  axiom compareAppDataValue : AppDataValue -> AppDataValue -> Ordering;

  --- Implements the ;Ord; trait for ;AppDataKey;.
  instance
  AppDataKey-Ord : Ord AppDataKey :=
    mkOrd@{
      cmp := compareAppDataKey
    };

  --- Implements the ;Eq; trait for ;AppDataKey;.
  instance
  AppDataKey-Eq : Eq AppDataKey := fromOrdToEq;

  --- Implements the ;Ord; trait for ;AppDataValue;.
  instance
  AppDataValue-Ord : Ord AppDataValue :=
    mkOrd@{
      cmp := compareAppDataValue
    };

  --- Implements the ;Eq; trait for ;AppDataValue;.
  instance
  AppDataValue-Eq : Eq AppDataValue := fromOrdToEq;

  --- A type describing an app data map entry.
  AppDataEntry : Type := Pair AppDataKey AppDataValue;

  --- A type describing an app data map.
  AppData : Type := Set AppDataEntry;
end;

open AppDataInternal using {AppData} public;

--- The record describing an action and defining the proof context.
--- A proof created in the context of an action is assumed to have guaranteed
--- access only to the resources associated with the action.
type Action :=
  mkAction {
    commitments : Set Resource.Commitment;
    nullifiers : Set Resource.Nullifier;
    proofs : ProofRecordSet;
    appData : AppData
  };

type DuplicatedCommitment := mkDuplicatedCommitment;
-- Resource.Commitment

type DuplicatedNullifier := mkDuplicatedNullifier;
-- Resource.Nullifier;

type DuplicateError :=
  | DuplicatedCommitmentError DuplicatedCommitment
  | DuplicatedNullifierError DuplicatedNullifier;

disjointUnion {T} {{Eq T}} {{Ord T}} (s1 s2 : Set T) : Maybe (Set T) :=
  if
    | intersection s1 s2 == Set.empty := just (union s1 s2)
    | else := nothing;

--- Composes two ;Action; objects.
compose (a1 a2 : Action) : Result DuplicateError Action :=
  let
    cms :=
      disjointUnion@{
        s1 := Action.commitments a1;
        s2 := Action.commitments a2
      };
    nfs :=
      disjointUnion@{
        s1 := Action.nullifiers a1;
        s2 := Action.nullifiers a2
      };
  in case cms, nfs of
       | nothing, _ := error (DuplicatedCommitmentError mkDuplicatedCommitment)
       | _, nothing := error (DuplicatedNullifierError mkDuplicatedNullifier)
       | just commitments, just nullifiers :=
         ok
           mkAction@{
             commitments;
             nullifiers;
             appData :=
               union@{
                 s1 := Action.appData a1;
                 s2 := Action.appData a2
               };
             -- TODO Proofs must be recomputed. Should this happen as part of `compose`?
             proofs := ProofRecordSet.empty
           };

{-
Action validity:
- action input resources have valid resource logic proofs associated with them
- action output resources have valid resource logic proofs associated with them
- all compliance proofs are valid
- transaction's  field contains valid roots used to prove the existence of consumed resources in the compliance proofs.
  -- TODO Ask Yulia: What does it mean for a root to be valid?
-}

verify (a : Action) : Bool := ProofRecordSet.verify (Action.proofs a);

module ActionInternal;
  --- Compares two ;Action; objects.
  axiom compare : (a1 a2 : Action) -> Ordering;

  --- Implements the ;Ord; trait for ;Action;.
  instance
  Action-Ord : Ord Action :=
    mkOrd@{
      cmp := compare
    };

  --- Implements the ;Eq; trait for ;Action;.
  instance
  Action-Eq : Eq Action := fromOrdToEq;
end;
