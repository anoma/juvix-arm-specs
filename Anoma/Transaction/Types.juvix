module Anoma.Transaction.Types;

import Data.Set as Set open using {Set; toList; union};
import Stdlib.Prelude open using {for; all; &&; just; nothing; Result; error; ok; Bool};
import Anoma.Resource.Computable.Commitment as Resource open using {Commitment};
import Anoma.Resource.Computable.Nullifier as Resource open using {Nullifier};
import Anoma.State.CommitmentTree as CommitmentTree open using {Root};
import Anoma.Transaction.Action as Action open;
import Anoma.Delta as Delta open using {Delta};
import Anoma.MathProperty open;
import Anoma.ProvingSystem.Types open;
import Anoma.ProvingSystem.DeltaProof as DeltaProof;

--- A record describing a transaction object, the entity constituting a state transition in Anoma.
positive
type Transaction :=
  mkTransaction {
    roots : Set CommitmentTree.Root;
    actions : Set Action;
    delta : Delta;
    deltaProof : DeltaProof.ProofRecord
  };

--- The ;Transaction; object constructor signature.
Constructor : Type :=
  (roots : Set CommitmentTree.Root)
    -> (actions : Set Action)
    -> (delta : Delta)
    -> (deltaProof : DeltaProof.ProofRecord)
    -> Transaction;

--- Composes two ;Transaction; objects.
compose (tx1 tx2 : Transaction) : Transaction :=
  mkTransaction@{
    roots := union (Transaction.roots tx1) (Transaction.roots tx2);
    actions := union (Transaction.actions tx1) (Transaction.actions tx2);
    delta := AdditivelyHomomorphic.add (Transaction.delta tx1) (Transaction.delta tx2);
    deltaProof := DeltaProof.aggregate (Transaction.deltaProof tx1) (Transaction.deltaProof tx2)
  };

verify (tx : Transaction) : Bool :=
  all (a in Set.toList (Transaction.actions tx)) {Action.verify a}
    && DeltaProof.verify (Transaction.deltaProof tx);

--- Returns the ;Resource.Commitment; ;Set; of a ;Transaction;.
commitmentSet (transaction : Transaction) : Result DuplicatedCommitment (Set Resource.Commitment) :=
  for (acc := ok Set.empty) (a in Transaction.actions transaction)
    {case acc of
      | ok acc' :=
        case disjointUnion acc' (Action.commitments a) of {
          | just cms := ok cms
          | nothing := error mkDuplicatedCommitment
        }
      | error err := error err};

--- Returns the ;Resource.Nullifier; ;Set; of a ;Transaction;.
nullifierSet (transaction : Transaction) : Result DuplicatedNullifier (Set Resource.Nullifier) :=
  for (acc := ok Set.empty) (a in Transaction.actions transaction)
    {case acc of
      | ok acc' :=
        case disjointUnion acc' (Action.nullifiers a) of {
          | just nfs := ok nfs
          | nothing := error mkDuplicatedNullifier
        }
      | error err := error err};

-- TODO refactor
