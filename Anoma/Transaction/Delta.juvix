module Anoma.Transaction.Delta;

import Stdlib.Prelude open using {Bool; List; for; ||};
import Data.Set as Set open using {Set; union; member?};
import Anoma.Delta as Delta open;
import Anoma.Transaction.Types open;
import Anoma.Transaction.Action open;
import Anoma.Resource.Index as Resource open;
import Anoma.MathProperty as MathProperty open;

module TransactionDeltaInternal;
  isInCommitmentSet (resource : Resource) (transaction : Transaction) : Bool :=
    let
      actions : List Action := Set.toList (Transaction.actions transaction);
      cm : Resource.Commitment := Resource.commitment resource;
      cms : Set Resource.Commitment :=
        for (acc := Set.empty) (a in actions) {union acc (Action.commitments a)};
    in member? cm cms;

  isInNullifierSet
    (resource : Resource)
    (nullifierKey : Resource.NullifierKey)
    (transaction : Transaction)
    : Bool :=
    let
      actions : Set Action := Transaction.actions transaction;
      nf : Resource.Nullifier :=
        Resource.nullifier@{
          resource;
          nullifierKey
        };
      nfs : Set Resource.Nullifier :=
        for (acc := Set.empty) (a in actions) {union acc (Action.nullifiers a)};
    in member? nf nfs;
end;

delta
  (resources : Set Resource)
  (nullifierKey : Resource.NullifierKey)
  (transaction : Transaction)
  : Delta :=
  for (acc := Delta.zero) (r in resources)
    {if
      | TransactionDeltaInternal.isInCommitmentSet@{
          resource := r;
          transaction
        }
        || TransactionDeltaInternal.isInNullifierSet@{
          resource := r;
          nullifierKey;
          transaction
        } := MathProperty.AdditivelyHomomorphic.add acc (Resource.delta r)
      | else := acc};
